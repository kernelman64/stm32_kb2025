#include <stdint.h>
#include <stm32f10x.h>
#include <stdbool.h>

#define LCD_W 128
#define LCD_H 8
#define font_W 11

int seconds[4] = {0,0,0,0};
bool timersEnabled[4] = {false, false, false, false};

uint8_t font[2][font_W * 10] = {// 'font2', 110x16px
0xfe, 0x06, 0x02, 0x02, 0xc2, 0xc2, 0x02, 0x02, 0x06, 0xfe, 0x00, 0xc0, 0x40, 0x20, 0xf8, 0xfe, 
0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x1c, 0x06, 0x02, 0x02, 0x02, 0x06, 0x04, 0xf8, 0x00, 
0x00, 0x04, 0x06, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0xc6, 0x7c, 0x00, 0xfe, 0x80, 0x80, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x80, 0xfe, 0x00, 0x7e, 0x42, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x42, 
0x82, 0x00, 0x0c, 0x06, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x06, 0xfc, 0x00, 0x06, 0x06, 0x04, 
0x0c, 0x08, 0x08, 0xc8, 0x64, 0x16, 0x1e, 0x00, 0x7c, 0x86, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x86, 0x7c, 0x00, 0x78, 0x84, 0x82, 0x02, 0x02, 0x02, 0x02, 0x82, 0x84, 0xf8, 0x00, 0x7f, 0x60, 
0x40, 0x40, 0x43, 0x43, 0x40, 0x40, 0x60, 0x7f, 0x00, 0x40, 0x40, 0x40, 0x60, 0x7f, 0x7f, 0x40, 
0x40, 0x40, 0x40, 0x00, 0x60, 0x30, 0x38, 0x28, 0x28, 0x24, 0x42, 0x42, 0x41, 0x40, 0x00, 0x20, 
0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x41, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x40, 0x3f, 0x00, 0x38, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3f, 0x00, 
0x1e, 0x21, 0x41, 0x40, 0x40, 0x40, 0x40, 0x41, 0x21, 0x1f, 0x00, 0x00, 0x61, 0x71, 0x0d, 0x07, 
0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x1e, 0x21, 0x41, 0x40, 0x40, 0x40, 0x40, 0x41, 0x21, 0x1e, 
0x00, 0x30, 0x60, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x60, 0x3f, 0x00};
uint8_t LCD_buf[LCD_H][LCD_W] = {// 'image_edited', 128x64px
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x83, 0x81, 0x81, 0x81, 0x81, 0x81, 0xff, 0xff, 0x00, 
0x00, 0xff, 0xff, 0x81, 0x81, 0x81, 0x81, 0x81, 0x83, 0x87, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 
0xff, 0x03, 0x01, 0x01, 0x01, 0x01, 0x03, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 
0x0c, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x83, 0x81, 0x81, 
0x81, 0x81, 0x81, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x81, 0x81, 0x81, 0x81, 0x81, 0x83, 0x87, 
0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0xff, 0x03, 0x01, 0x01, 0x01, 0x01, 0x03, 0xff, 0xff, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 0x0c, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x60, 0x40, 0x40, 0x40, 0x40, 0x60, 0x60, 0x00, 
0x00, 0x7f, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x41, 0x43, 0x7f, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 
0x7f, 0x60, 0x40, 0x40, 0x40, 0x40, 0x60, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
0x40, 0x7f, 0x7f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x60, 0x40, 
0x40, 0x40, 0x40, 0x60, 0x60, 0x00, 0x00, 0x7f, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x41, 0x43, 0x7f, 
0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x7f, 0x60, 0x40, 0x40, 0x40, 0x40, 0x60, 0x7f, 0x7f, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x7f, 0x7f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x83, 0x81, 0x81, 0x81, 0x81, 0x81, 0xff, 0xff, 0x00, 
0x00, 0xff, 0xff, 0x81, 0x81, 0x81, 0x81, 0x81, 0x83, 0x87, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 
0xff, 0x03, 0x01, 0x01, 0x01, 0x01, 0x03, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 
0x0c, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x83, 0x81, 0x81, 
0x81, 0x81, 0x81, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x81, 0x81, 0x81, 0x81, 0x81, 0x83, 0x87, 
0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0xff, 0x03, 0x01, 0x01, 0x01, 0x01, 0x03, 0xff, 0xff, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 0x0c, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x60, 0x40, 0x40, 0x40, 0x40, 0x60, 0x60, 0x00, 
0x00, 0x7f, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x41, 0x43, 0x7f, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 
0x7f, 0x60, 0x40, 0x40, 0x40, 0x40, 0x60, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
0x40, 0x7f, 0x7f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x60, 0x40, 
0x40, 0x40, 0x40, 0x60, 0x60, 0x00, 0x00, 0x7f, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x41, 0x43, 0x7f, 
0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x7f, 0x60, 0x40, 0x40, 0x40, 0x40, 0x60, 0x7f, 0x7f, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x7f, 0x7f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

void delay_us(uint32_t us){
    __asm volatile(
        "push {r0}\r\n"
        "mov R0, %0\r\n"      //val = (9 * us) for 72Mhz
        "_loop:\r\n"    //approx. 8ticks/iteration
	        "cmp R0, #0\r\n" //1
	        "beq _exit\r\n"      		//1 or 1+P (when condition is True)
	        "sub R0, R0, #1\r\n" 	//1
	        "nop\r\n" 				//1 allignment
	        "b _loop\r\n" 			//1+P (pipeline refill) ~4 cycle
        "_exit:\r\n"
	        "pop {r0}\r\n"
        :: "r"(9*us) // For 72 Mhz
    );
}

void delay_ms(uint32_t ms){
    delay_us(1000 * ms);  
}

void SPI1_Write(uint8_t data){
    while(!(SPI1->SR & SPI_SR_TXE));
    SPI1->DR = data;
}

uint8_t SPI1_Read(void){
    SPI1->DR=0;
    while(!(SPI1->SR & SPI_SR_RXNE));
    return SPI1->DR;
}

void cmd(uint8_t data){
    GPIOA->ODR &= ~GPIO_ODR_ODR12;
    GPIOA->ODR &= ~GPIO_ODR_ODR4;
    delay_us(1000);
    SPI1_Write(data);
    GPIOA->ODR |= GPIO_ODR_ODR4;
}

void dat(uint8_t data){
    GPIOA->ODR |= GPIO_ODR_ODR12;
    GPIOA->ODR &= ~GPIO_ODR_ODR4;
    delay_us(1000);
    SPI1_Write(data);
    GPIOA->ODR |= GPIO_ODR_ODR4;
}

void load_buf(){
    for(int i=0; i<8; i++){
        cmd(0b10110000 | i); // page = i
        cmd(0b00010000);     // column = 0
        cmd(0b00000000);
        for(int j=0; j<129; j++){
            dat(LCD_buf[i][j]);
        }
    }
}
    
void update_digit(int x, int y, int digit){
    int p = x / 8;
    cmd(0b10110000 | p);
    cmd(0b00010000 | ((y & 0b11110000) >> 4));     // column = 0
    cmd(0b00000000 | (y & 0b1111));
    for(int i = 0; i < font_W; i++)
    {
        LCD_buf[p][y + i] = font[0][font_W * digit + i]; //page 1
        dat(LCD_buf[p][y + i]);
    }
    cmd(0b10110000 | (p + 1));
    cmd(0b00010000 | ((y & 0b11110000) >> 4));     // column = 0
    cmd(0b00000000 | (y & 0b1111));
    for(int i = 0; i < font_W; i++)
    {
        LCD_buf[p + 1][y + i] = font[1][font_W * digit + i]; //page 2
        dat(LCD_buf[p + 1][y + i]);
    }
}

void update_timer(int timer, int hours, int minutes){
    int x, y;
    int timers[4][2] = {{6, 8}, {76, 8}, {6, 48}, {76, 48}};
    y = timers[timer - 1][0];
    x = timers[timer - 1][1];
    update_digit(x, y, hours / 10);
    update_digit(x, y + font_W, hours % 10);
    update_digit(x, y + font_W * 2 + 4, minutes / 10);
    update_digit(x, y + font_W * 3 + 4, minutes % 10);
}

/* Interrupt handler */
void TIM2_IRQHandler(void) {
    if (TIM2->SR & TIM_SR_UIF) {
        if(GPIOC->ODR & GPIO_ODR_ODR13){
            GPIOC->ODR &= ~GPIO_ODR_ODR13;
        } else {
            GPIOC->ODR |= GPIO_ODR_ODR13;
        }
    for(int i=0; i<4; i++){
        if(timersEnabled[i] == true){
                seconds[i] += 1;
                update_timer(i + 1, seconds[i] / 60, seconds[i] % 60);
        }
    }

    //Clear Interrupt flag
    TIM2->SR &= ~TIM_SR_UIF;
    }
}

int main(void) {
    load_buf();
    // int i = 0;
    // int mask = 8; // 8 = 0b10000 = 0x8 = (1 << 4)
    // i = i | mask; // i |= mask;

    /* IO PORTS Configuration */
    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN | RCC_APB2ENR_IOPBEN | RCC_APB2ENR_IOPAEN | RCC_APB2ENR_SPI1EN; // 0b10000=0x10
    GPIOC->CRH &= ~(GPIO_CRH_CNF13 | GPIO_CRH_MODE13); // GPIOC->CRH[23:20]=0000
    GPIOC->CRH |= GPIO_CRH_MODE13_0; // GPIOC->CRH[23:20]=0001

    // Buttons
    GPIOB->CRH &= ~(GPIO_CRH_CNF12 | GPIO_CRH_MODE12); // GPIOB->CRH[CNF12,MODE12]=0000
    GPIOB->CRH |= GPIO_CRH_CNF12_1; // GPIOC->CRH[23:20]=0001

    GPIOB->CRH &= ~(GPIO_CRH_CNF13 | GPIO_CRH_MODE13); 
    GPIOB->CRH |= GPIO_CRH_CNF13_1; 

    GPIOB->CRH &= ~(GPIO_CRH_CNF14 | GPIO_CRH_MODE14);
    GPIOB->CRH |= GPIO_CRH_CNF14_1; 

    GPIOB->CRH &= ~(GPIO_CRH_CNF15 | GPIO_CRH_MODE15); 
    GPIOB->CRH |= GPIO_CRH_CNF15_1; 

    GPIOB->ODR |= (GPIO_ODR_ODR12 | GPIO_ODR_ODR13 | GPIO_ODR_ODR14 | GPIO_ODR_ODR15);

    // A9 A10
    GPIOA->CRH &= ~(GPIO_CRH_CNF9 | GPIO_CRH_MODE9); 
    GPIOA->CRH |= GPIO_CRH_MODE9_0;
    GPIOA->CRH |= GPIO_CRH_CNF9_1; 

    GPIOA->CRH &= ~(GPIO_CRH_CNF10 | GPIO_CRH_MODE10); 
    GPIOA->CRH |= GPIO_CRH_CNF10_1; 
    GPIOA->ODR |= GPIO_ODR_ODR10;

    // SPI IO Configuration
    GPIOA->CRL &= ~(GPIO_CRL_CNF4 | GPIO_CRL_MODE4); // GPIOA->CRL[19:16]=0000
    GPIOA->CRL |= GPIO_CRL_MODE4_0; // GPIOA->CRL[19:16]=0001

    GPIOA->CRH &= ~(GPIO_CRH_CNF11 | GPIO_CRH_MODE11);
    GPIOA->CRH |= GPIO_CRH_MODE11_0; 

    GPIOA->CRH &= ~(GPIO_CRH_CNF12 | GPIO_CRH_MODE12);
    GPIOA->CRH |= GPIO_CRH_MODE12_0;

    GPIOA->CRL &= ~(GPIO_CRL_CNF5 | GPIO_CRL_MODE5); // GPIOA->CRL[23:20]=0000
    GPIOA->CRL |= GPIO_CRL_MODE5_0; // GPIOA->CRL[23:20]=0001
    GPIOA->CRL |= GPIO_CRL_CNF5_1;

    GPIOA->CRL &= ~(GPIO_CRL_CNF7 | GPIO_CRL_MODE7);
    GPIOA->CRL |= GPIO_CRL_MODE7_0; 
    GPIOA->CRL |= GPIO_CRL_CNF7_1;

    SPI1->CR1 &= ~SPI_CR1_DFF;      //DFF=0
    SPI1->CR1 &= ~SPI_CR1_CRCEN;    //CRCEN=0
    SPI1->CR1 |= SPI_CR1_SSM;       //SSM=1
    SPI1->CR1 |= SPI_CR1_SSI;       //SSI=1
    SPI1->CR1 &= ~SPI_CR1_BR;       //BR[2:0]=100
   //SPI1->CR1 |= SPI_CR1_BR_1;      
    SPI1->CR1 |= SPI_CR1_MSTR;      //MSTR=1
    SPI1->CR1 &= ~SPI_CR1_CPOL;     //CPOL=0
    SPI1->CR1 &= ~SPI_CR1_CPHA;     //CPHA=0
    SPI1->CR1 |= SPI_CR1_SPE;       //SPE=1

    // Display initialization
    GPIOA->ODR &= ~GPIO_ODR_ODR4; // CS=0
    GPIOA->ODR &= ~GPIO_ODR_ODR11; // RESET=0 - аппаратный сброс
    delay_us(10000); // Wait for the power stabilized
    GPIOA->ODR |= GPIO_ODR_ODR11; // RESET=1
    delay_us(1000); // Wait <1ms
    cmd(0xA2); //LCD Drive set 1/9 bias
    cmd(0xA0); // RAM Address SEG Output normal
    cmd(0xC8); // Common output mode selection
    cmd(0x28 | 0x07); // Power control mode
    cmd(0x20 | 0x05); // Voltage regulator
    cmd(0xA6); // Normal color, A7 = inverse color
    cmd(0xAF); // Display on

    /* TIM2 Configuration */
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
    RCC->APB1RSTR |= RCC_APB1RSTR_TIM2RST;
    RCC->APB1RSTR &= ~RCC_APB1RSTR_TIM2RST;
    TIM2->PSC = 4000;
    TIM2->ARR = 20000;
    TIM2->DIER |= TIM_DIER_UIE; // Enable Update Interrupt
    NVIC_ClearPendingIRQ(TIM2_IRQn);
    NVIC_EnableIRQ(TIM2_IRQn); // Enable IRQ in NVIC
    TIM2->CR1 |= TIM_CR1_CEN; // Start timer

    // Port PB0 as Input
    RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
    GPIOB->CRL &= ~(GPIO_CRL_CNF0 | GPIO_CRL_MODE0); // GPIOB->CRL[3:0]=0000
    GPIOB->CRL |= GPIO_CRL_CNF0_1; // GPIOB->CRL[3:0]=1000
    GPIOB->ODR |= GPIO_ODR_ODR0; // PB0 Internal pull-up resister

    /* TIM2 Configuration */
    /*RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
    RCC->APB1RSTR |= RCC_APB1RSTR_TIM2RST;
    RCC->APB1RSTR &= ~RCC_APB1RSTR_TIM2RST;
    TIM2->PSC = 4000;
    TIM2->ARR = 20000;
    TIM2->DIER |= TIM_DIER_UIE; // Enable Update Interrupt
    NVIC_ClearPendingIRQ(TIM2_IRQn);
    NVIC_EnableIRQ(TIM2_IRQn); // Enable IRQ in NVIC
    TIM2->CR1 |= TIM_CR1_CEN; // Start timer
    while (1) {
        __asm volatile ("nop");
    }*/

    //cmd(0xB0);
    
    //cmd(0x00);
    //load_buf();

    /*
    for(int i=0; i<8; i++){
        cmd(0b10110000 | i); // page = i
        cmd(0b00010000);     // column = 0
        cmd(0b00000000);
        for(int j=0; j<129; j++){
            dat(0b10101010);
        }
    }
   
    while(1){
        if(GPIOB->IDR & GPIO_IDR_IDR0){
            GPIOC->ODR &= ~GPIO_ODR_ODR13;
        } else {
            GPIOC->ODR |= GPIO_ODR_ODR13;
        }
        dat(0b10101010);
    }*/

    /*while(1){
        GPIOC->ODR &= ~GPIO_ODR_ODR13;
        delay_us(1000000);
        GPIOC->ODR |= GPIO_ODR_ODR13;
        delay_us(1000000);
    }*/
    for(int i=0; i<4; i++){
        update_timer(i + 1, 0, 0);
    }


    //update_timer(3,12,16);
    uint32_t count = 0;

    while(1){

        if ((GPIOB->IDR & GPIO_IDR_IDR12) == 0){
            count = 0;
            delay_us(50);
            while((GPIOB->IDR & GPIO_IDR_IDR12) == 0){
                count += 1;
            }
            delay_us(50);
            if (count > 2500000){
                update_timer(1, 0, 0);
                seconds[0] = 0;
                timersEnabled[0] = false;
            }
            else{
                if (timersEnabled[0] == false){
                    timersEnabled[0] = true;
                }
                else{
                    timersEnabled[0] = false;
                }
            }
        }

        if ((GPIOB->IDR & GPIO_IDR_IDR13) == 0){
            count = 0;
            delay_us(50);
            while((GPIOB->IDR & GPIO_IDR_IDR13) == 0){
                count += 1;
            }
            delay_us(50);
            if (count > 2500000){
                update_timer(2, 0, 0);
                seconds[1] = 0;
                timersEnabled[1] = false;
            }
            else{
                if (timersEnabled[1] == false){
                    timersEnabled[1] = true;
                }
                else{
                    timersEnabled[1] = false;
                }
            }
            }

        if ((GPIOB->IDR & GPIO_IDR_IDR14) == 0){
            count = 0;
            delay_us(50);
            while((GPIOB->IDR & GPIO_IDR_IDR14) == 0){
                count += 1;
            }
            delay_us(50);
            if (count > 2500000){
                update_timer(3, 0, 0);
                seconds[2] = 0;
                timersEnabled[2] = false;
            }
            else{
                if (timersEnabled[2] == false){
                    timersEnabled[2] = true;
                }
                else{
                    timersEnabled[2] = false;
                }
            }
        }

        if ((GPIOB->IDR & GPIO_IDR_IDR15) == 0){
            count = 0;
            delay_us(50);
            while((GPIOB->IDR & GPIO_IDR_IDR15) == 0){
                count += 1;
            }
            delay_us(50);
            if (count > 2500000){
                update_timer(4, 0, 0);
                seconds[3] = 0;
                timersEnabled[3] = false;
            }
            else{
                if (timersEnabled[3] == false){
                    timersEnabled[3] = true;
                }
                else{
                    timersEnabled[3] = false;
                }
            }
        }

    };
return 0;
}
